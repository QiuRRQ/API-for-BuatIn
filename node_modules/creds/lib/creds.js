/**
 * @fileOverview This file provides classes related to authentication and role based permissions.
 * @author <a href="mailto:paul.bottin+creds@gmail.com">Paul Bottin</a>
 * @version 1.0.0
 */

/**
 * provides two classes, {@link creds.users} and {@link creds.roles}<br/>
 * @example
 *	var creds = require('creds');
 *	
 *	var u = creds.users({
 *		
 *		// passwords
 *		'admin': 'nimda',
 *		'user':	'resu'
 *		
 *	});
 *	
 *	var r = creds.roles({
 *		
 *		// users
 *		'anonymous': [],
 *		'admin': ['admins'],
 *		'user': ['users'],
 *		
 *		// groups
 *		'admins': ['users'],
 *		'users': ['registered'],
 *		'registered': []
 *		
 *	});
 *   
 *	u('admin', 'nimda');		// => true
 *	r('admin', 'registered');	// => true
 *
 * @name creds
 * @namespace
 */

/**
 * stores user names and their passwords
 * @name creds.users
 * @constructor
 * @param {Object} data
 * @returns {creds.users}
 */
function users (data) {

	/**
	 * checks if the given password matches that of the given user
	 * @name creds.users#checkUser
	 * @function
	 * @param {String} username
	 * @param {String} password
	 * @returns {Boolean}
	 */
	function checkUser (username, password) {
		return	(username			!==	undefined)		// no user name given
		&&		(username.length	 >	0)				// empty user name given
		&&		(data[username]		!==	undefined)		// unknown user name
		&&		(password			!==	undefined)		// no password given
		&&		(password.length	 >	0)				// empty password given
		&&		(data[username]		 ==	password)		// password mismatch
		;
	};
	checkUser.checkUser = checkUser;
	
	/**
	 * gets a list of known user names
	 * @name creds.users#usernames
	 * @property
	 * @constant
	 * @type Array
	 */
	checkUser.__defineGetter__('usernames', function () {
		return Object.keys(data);
	});
	
	Object.freeze(checkUser);
	Object.seal(checkUser);
	return checkUser;
}
exports.users = users;
Object.freeze(users);
Object.seal(users);

/**
 * stores role assignments
 * @name creds.roles
 * @constructor
 * @param {Object} data
 * @returns {creds.roles}
 */
function roles (data) {
	
	/**
	 * checks if the role is membership or owns inherited membership
	 * @name creds.roles#checkRole
	 * @function
	 * @param {String} role
	 * @param {String} membership
	 * @returns {Boolean}
	 */
	function checkRole (role, membership) {
		var result = false;
		if ( 	(role				!==	undefined)		// no role given
		&&		(role.length		 >	0)				// empty role given
		&&		(data[role]			!==	undefined)		// unknown role
		&&		(membership			!==	undefined)		// no membership given
		&&		(membership.length	 >	0)				// empty membership given
		) {
			if (role == membership)
				result = true;
			data[role].forEach(function (m) {
				if (membership == m)
					result = true;
				else
					result = result || checkRole(m, membership);
			});
			
		}
		return result;
	}
	checkRole.checkRole = checkRole;
	
	/**
	 * gets a list of known roles
	 * @name creds.roles#roles
	 * @property
	 * @constant
	 * @type Array
	 */
	checkRole.__defineGetter__('roles', function () {
		return Object.keys(data);
	});
	
	/**
	 * gets all inherited roles of a role
	 * @name creds.roles#activeRoles
	 * @function
	 * @param {String} role
	 * @returns {Array}
	 */
	function activeRoles (role) {
		return Object.keys(data).filter(function (r) {
			return checkRole(role, r);
		});;
	}
	checkRole.activeRoles = activeRoles;

	Object.freeze(checkRole);
	Object.seal(checkRole);
	return checkRole;
}
exports.roles = roles;

Object.freeze(roles);
Object.seal(roles);

Object.freeze(exports);
Object.seal(exports);
